#ifndef OBJ_SURFACE_NORMAL_CL
# define OBJ_SURFACE_NORMAL_CL

#include "shared.h"
#include "host.h"

t_real3			obj_surface_normal_ext(t_obj *obj, t_real3 point);
t_real3			obj_surface_normal(t_obj *obj, t_real3 point, t_ray ray);
t_real3			obj_sphere_surface_normal(t_sphere *sphere, t_real3 point);
t_real3			obj_plane_surface_normal(t_plane *plane, t_real3 point);
t_real3			normal_reflect_ray(t_real3 normal, t_ray ray);
t_real3			obj_aligned_cube_surface_normal(t_aligned_cube *aligned_cube, t_real3 point);

t_real3			normal_reflect_ray(t_real3 normal, t_ray ray)
{
	if (dot(normal, ray.dir) < 0)
		return (normal);
	return (-normal);
}

t_real3			obj_surface_normal(t_obj *obj, t_real3 point, t_ray ray)
{
	return (normal_reflect_ray(obj_surface_normal_ext(obj, point), ray));
}

t_real3			obj_surface_normal_ext(t_obj *obj, t_real3 point)
{
	if (obj->type == e_type_sphere)
		return (obj_sphere_surface_normal(&obj->as.sphere, point));
	else if (obj->type == e_type_plane)
		return (obj_plane_surface_normal(&obj->as.plane, point));
	else if (obj->type == e_type_aligned_cube)
		return (obj_aligned_cube_surface_normal(&obj->as.aligned_cube, point));
	return ((t_real3)(0, 0, 0));
}

t_real3			obj_aligned_cube_surface_normal(t_aligned_cube *aligned_cube, t_real3 point)
{
	t_real3s	normal;
	t_real3		extents;
	t_real3s	dist;
	t_real3s	pt;
	t_real		min;
	int			i;

	i = 0;
	pt.v = point;
	min = FLT_MAX;
	pt.v -= aligned_cube->pos;
	extents = aligned_cube->size / 2; 
	dist.v = fabs(extents - fabs(pt.v));
	min = fmin(dist.v.x, fmin(dist.v.y, dist.v.z));
/*
	if (dist.x < min)
	if (min == dist.x)
	{
		min = dist.x;
		normal = (point.x >= 0.0) ? (t_real3)(1, 0, 0) : (t_real3)(-1, 0, 0);
		normal.x = (point.x >= 0.0) ? 1 : -1;
	}
	if (dist.y < min)
	if (min == dist.y)
	{
		min = dist.y;
		normal = (point.y >= 0.0) ? (t_real3)(0, 1, 0) : (t_real3)(0, -1, 0);
		normal.y = (point.y >= 0) ? 1 : -1;
	}
	if (dist.z < min)
	if (min == dist.z)
	{
		min = dist.z;
		normal = (point.z >= 0.0) ? (t_real3)(0, 0, 1) : (t_real3)(0, 0, -1);
		normal.z = (point.z >= 0.0) ? 1 :  -1;
	}
*/
	while (i < 3)
	{
		if (min - dist.s[i] <= 1e-3)
			normal.s[i] = pt.s[i] / fabs(pt.s[i]);
		else
			normal.s[i] = 0;
		i++;
	}
	return (normal.v);
}

t_real3			obj_sphere_surface_normal(t_sphere *sphere, t_real3 point)
{
	t_real3		normal;

	normal = point - sphere->pos;
	normal = normalize(normal);
	return (normal);
}

t_real3			obj_plane_surface_normal(t_plane *plane, t_real3 point)
{
	return (plane->normal);
}

#endif
